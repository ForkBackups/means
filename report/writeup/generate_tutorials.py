import os
import sys
import re
import shutil
import tempfile

def remove_in_tags(match):
    code_block = match.group(0)
    lines = code_block.split('\n')
    answer_lines = []

    # Append the incolor
    start_line = lines[0]
    end_line = lines[-1]
    strip_length = None
    type = None
    for line in lines[1:-1]:
        if strip_length is None:
            match = re.match(r"\{\\color\{(in|out)color\}(?P<type>In |Out)\[\{\\color\{(in|out)color\}(?P<digit>\d+)\}\]:\}", line)

            if match:

                line = line[len(match.group(0))+1:]
                type = match.group('type')
                strip_length = len(match.group('digit')) + len(type) + 4
        else:
            line = line[strip_length:]

        answer_lines.append(line)

    if type is None:
        start_line = start_line.replace(r"\begin{Verbatim}", r"\begin{StdOutVerbatim}")
        end_line = end_line.replace(r"\end{Verbatim}", r"\end{StdOutVerbatim}")
    elif type == 'In ':
        start_line = start_line.replace(r"\begin{Verbatim}", r"\begin{InputVerbatim}")
        end_line = end_line.replace(r"\end{Verbatim}", r"\end{InputVerbatim}")
    elif type == 'Out':
        start_line = start_line.replace(r"\begin{Verbatim}", r"\begin{OutputVerbatim}")
        end_line = end_line.replace(r"\end{Verbatim}", r"\end{OutputVerbatim}")
    else:
        raise Exception("Unknown output type")

    return '\n'.join([start_line] + answer_lines + [end_line])


def process_file(filename, resulting_filename):
    # Hacky, I know, but faster than finding the way to do that programmatically
    cmd = 'ipython nbconvert --to latex "{0}"'.format(filename)
    print '> {0}'.format(cmd)
    os.system(cmd)



    with open(resulting_filename, 'r') as f:
        contents = f.read()

    # Lets make it a standalone document so we can include it later on
    contents = contents.replace(r'\documentclass{article}', r'\documentclass{standalone}')
    contents = contents.replace(r'\maketitle', '')  # Remove the title, who needs it...

    # Remove the %pylab declaration
    contents = re.sub(r"\\begin\{Verbatim\}(.|\n)*?pylab(.|\n)*?\\end\{Verbatim\}", "", contents, re.MULTILINE)
    # Remove it's result
    contents = re.sub(r"\\begin\{Verbatim\}(.|\n)*?interactive namespace(.|\n)*?\\end\{Verbatim\}", "", contents, re.MULTILINE)

    # Move section names one level down
    contents = re.sub(r"\\paragraph", "\\subparagraph", contents)
    contents = re.sub(r"\\subsubsection\{(.*?)\}", r"\\paragraph{\1}", contents)
    contents = re.sub(r"\\subsection", "\\subsubsection", contents)
    contents = re.sub(r"\\section", "\\subsection", contents)

    # ODEProblem formatting
    contents = contents.replace('<h1>ODEProblem</h1>', r'\textbf{ODEProblem}')
    contents = re.sub(r"<p>(.*?)</p>", r"\1 \\\\", contents)
    contents = re.sub(r"<code>(.*?)</code>", r"\\verb#\1#", contents)
    contents = contents.replace('<ul>', r'\begin{itemize}')
    contents = contents.replace('</ul>', r'\end{itemize}')
    contents = re.sub(r"<li>(.*?)</li>", r"\\item \1", contents)
    contents = contents.replace('<hr />', r'\rule{4cm}{0.4pt}')

    contents = contents.replace(r"$\LaTeX$", "\LaTeX")

    # Remove In [123]: blocks
    contents = re.sub(r"\\begin{Verbatim}(.|\n)*?\\end{Verbatim}", remove_in_tags, contents, flags=re.MULTILINE)


    # Change verbatims to use the version with background fill
    #contents = contents.replace(r"\begin{Verbatim}", r"\begin{BGVerbatim}")
    #contents = contents.replace(r"\end{Verbatim}", r"\end{BGVerbatim}")
    # Remove In [number]:
    #contents = re.sub(r"\{\\color\{incolor\}In \[\{\\color\{incolor\}\d+\}\]:\}", "", contents)

    # Remove standalone Out[]'s as well
    contents = re.sub(r"\\texttt\{\\color\{outcolor\}Out\[\{\\color\{outcolor\}\d+\}\]:\}",
                      r"{\\color{outcolor}Output:}", contents)
    # Remove the offset padding resulting from the removal of In
    #contents = re.sub(r"^\s+\\PY", r"\\PY", contents, flags=re.MULTILINE)


    with open(resulting_filename, 'w') as f:
        f.write(contents)



def main():

    ipynb_dir = sys.argv[1]

    temporary_dir = tempfile.mkdtemp()
    # Let's name all our tutorials "tutorial" so the output files are in "tutorial_files" dir
    temp_filename = os.path.join(temporary_dir, 'autogenerated-tutorial.ipynb')

    if not os.path.isdir(ipynb_dir):
        raise Exception("Expecting directory as first parameter")

    relative_path_to_this_file = os.path.dirname(__file__)
    if relative_path_to_this_file:
        # We need to work in the report directory
        os.chdir(relative_path_to_this_file)

    # Start new:
    if os.path.isdir('autogenerated-tutorial_files'):
        print '!!! Fount the autogenerated tutorial files directory, removing it'
        shutil.rmtree('autogenerated-tutorial_files')


    for filename in os.listdir('.'):
        if filename.startswith('autogenerated-tutorial') and (filename.endswith('.tex') or filename.endswith('.aux')):
            print '!!! found outogenerated tutorial file {0!r}, removing it'.format(filename)
            os.unlink(filename)


    counter = 0
    generated_filenames = []

    for local_filename in os.listdir(ipynb_dir):
        if not local_filename.endswith('.ipynb'):
            continue

        counter += 1

        filename = os.path.join(ipynb_dir, local_filename)
        print filename


        shutil.copy(filename, temp_filename)
        # Hacky, again. The output will always be in current working dir, anyways
        resulting_filename = os.path.basename(temp_filename[:-6]) + '.tex'

        process_file(temp_filename, resulting_filename)

        out_filename = 'autogenerated-tutorial-{0}.tex'.format(counter)
        os.rename(resulting_filename, out_filename)

        generated_filenames.append(out_filename)

    if counter > 0:
        os.unlink(temp_filename)
    os.rmdir(temporary_dir)

    input_all_tutorials = "\n".join([r'\input{{"{0}"}}'.format(f) for f in generated_filenames])
    with open("autogenerated-tutorials.tex", "w") as f:
        f.write(input_all_tutorials)


if __name__ == '__main__':
    main()